;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; NOTE: This test was ported using port_passes_tests_to_lit.py and could be cleaned up.

;; RUN: foreach %s %t wasm-opt --remove-unused-brs --all-features -S -o - | filecheck %s

(module
 ;; CHECK:      (type $vector (array (mut i32)))
 (type $vector (array (mut i32)))
 ;; CHECK:      (type $struct (struct (field (ref null $vector))))
 (type $struct (struct (field (ref null $vector))))
 ;; CHECK:      (type $i32_=>_none (func (param i32)))

 ;; CHECK:      (type $none_=>_funcref (func (result funcref)))

 ;; CHECK:      (type $none_=>_ref?|$struct| (func (result (ref null $struct))))

 ;; CHECK:      (type $none_=>_f64 (func (result f64)))

 ;; CHECK:      (type $none_=>_i32 (func (result i32)))

 ;; CHECK:      (type $i32_=>_funcref (func (param i32) (result funcref)))

 ;; CHECK:      (type $none_=>_none (func))

 ;; CHECK:      (import "out" "log" (func $log (type $i32_=>_none) (param i32)))
 (import "out" "log" (func $log (param i32)))
 ;; CHECK:      (elem declare func $br_on_non_null $br_on_null $i32_=>_none $none_=>_i32)

 ;; CHECK:      (func $foo (type $none_=>_ref?|$struct|) (result (ref null $struct))
 ;; CHECK-NEXT:  (if (result (ref null $struct))
 ;; CHECK-NEXT:   (i32.const 1)
 ;; CHECK-NEXT:   (struct.new $struct
 ;; CHECK-NEXT:    (array.new_default $vector
 ;; CHECK-NEXT:     (i32.const 1)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (ref.null none)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $foo (result (ref null $struct))
  (if (result (ref null $struct))
   (i32.const 1)
   (struct.new $struct
    ;; regression test for computing the cost of an array.new_default, which
    ;; lacks the optional field "init"
    (array.new_default $vector
     (i32.const 1)
    )
   )
   (ref.null $struct)
  )
 )

 ;; CHECK:      (func $test-prefinalize (type $none_=>_f64) (result f64)
 ;; CHECK-NEXT:  (loop $loop (result f64)
 ;; CHECK-NEXT:   (if (result f64)
 ;; CHECK-NEXT:    (i32.const 1)
 ;; CHECK-NEXT:    (f64.const 0)
 ;; CHECK-NEXT:    (block $block (result f64)
 ;; CHECK-NEXT:     (nop)
 ;; CHECK-NEXT:     (br_if $loop
 ;; CHECK-NEXT:      (i32.eqz
 ;; CHECK-NEXT:       (i32.const 0)
 ;; CHECK-NEXT:      )
 ;; CHECK-NEXT:     )
 ;; CHECK-NEXT:     (unreachable)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $test-prefinalize (result f64)
  (loop $loop (result f64)
   (block $block (result f64)
    (drop
     (br_if $block
      (f64.const 0)
      (i32.const 1)
     )
    )
    (if
     (i32.const 0)
     (unreachable)
    )
    ;; this will be moved from $block into the if right before it. we must be
    ;; careful to properly finalize() things, as if we finalize the block too
    ;; early - before the if - then the block ends in a none type, which is
    ;; invalid.
    (br $loop)
   )
  )
 )

 ;; CHECK:      (func $none_=>_i32 (type $none_=>_i32) (result i32)
 ;; CHECK-NEXT:  (unreachable)
 ;; CHECK-NEXT: )
 (func $none_=>_i32 (result i32)
  (unreachable)
 )
 ;; CHECK:      (func $i32_=>_none (type $i32_=>_none) (param $0 i32)
 ;; CHECK-NEXT:  (nop)
 ;; CHECK-NEXT: )
 (func $i32_=>_none (param i32)
 )
 ;; CHECK:      (func $selectify (type $i32_=>_funcref) (param $x i32) (result funcref)
 ;; CHECK-NEXT:  (select (result funcref)
 ;; CHECK-NEXT:   (ref.func $none_=>_i32)
 ;; CHECK-NEXT:   (ref.func $i32_=>_none)
 ;; CHECK-NEXT:   (local.get $x)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $selectify (param $x i32) (result funcref)
  ;; this if has arms with different function types, for which funcref is the
  ;; LUB
  (if (result funcref)
   (local.get $x)
   (ref.func $none_=>_i32)
   (ref.func $i32_=>_none)
  )
 )

 ;; CHECK:      (func $br_on_null (type $none_=>_none)
 ;; CHECK-NEXT:  (block $null
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (br_on_null $null
 ;; CHECK-NEXT:     (ref.null nofunc)
 ;; CHECK-NEXT:    )
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (drop
 ;; CHECK-NEXT:    (ref.func $br_on_null)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_null
  (block $null
   ;; A null reference to bottom is definitely null, and the br is always taken.
   ;; TODO: Optimize this.
   (drop
    (br_on_null $null (ref.null nofunc))
   )
   ;; On the other hand, if we know the input is not null, the branch will never
   ;; be taken.
   (drop
    (br_on_null $null (ref.func $br_on_null))
   )
  )
 )

 ;; CHECK:      (func $br_on_non_null (type $none_=>_funcref) (result funcref)
 ;; CHECK-NEXT:  (block $non-null (result (ref $none_=>_funcref))
 ;; CHECK-NEXT:   (br $non-null
 ;; CHECK-NEXT:    (ref.func $br_on_non_null)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (br_on_non_null $non-null
 ;; CHECK-NEXT:    (ref.null nofunc)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:   (ref.func $br_on_non_null)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT: )
 (func $br_on_non_null (result funcref)
  (block $non-null (result (ref func))
   ;; A non-null reference is not null, and the br is always taken.
   (br_on_non_null $non-null
    (ref.func $br_on_non_null)
   )
   ;; On the other hand, if we know the input is null, the branch will never be
   ;; taken.
   ;; TODO: Optimize this.
   (br_on_non_null $non-null
    (ref.null nofunc)
   )
   (ref.func $br_on_non_null)
  )
 )
)
